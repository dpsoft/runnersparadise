\documentclass{beamer}

\usepackage{minted}
\usepackage{tikz}
\usepackage{todonotes}

\setminted{frame=single}

\usetheme{codecentric}
\author{Markus Hauck}
\institute{codecentric AG}

\title{Functional Web Services}

\hypersetup{colorlinks,linkcolor=beamer@ccblue,urlcolor=links}

\begin{document}
{
  \usebackgroundtemplate{\includegraphics[width=\paperwidth,height=\paperheight]{background.png}}
  \begin{frame}[plain,noframenumbering]
    \titlepage{}
  \end{frame}
}

\section{Intro}

\begin{frame}
  \begin{center}
    \huge
    What are we gonna do tonight?
  \end{center}
\end{frame}

\begin{frame}
  \begin{center}
    \includegraphics[width=0.7\paperwidth]{pics/pinkybrain.jpg}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{What are we going to do tonight}
  \begin{itemize}
  \item write a small web service
  \item with http4s
  \item using an embedded DSL
  \item keep it functional
  \end{itemize}
\end{frame}

\begin{frame}{http4s}
  \begin{block}{What is \hyperlink{http://http4s.org/}{http4}}
    A typeful, purely functional, streaming library for HTTP
    clients and servers in Scala.
  \end{block}
  \begin{itemize}
  \item typeful \textemdash{} self-documentation and compile-time verification
  \item purely functional \textemdash{} promote composability and reasoning
  \item streaming \textemdash{} large payloads in constant space and websockets
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Embedded DSLs}
  \begin{itemize}
  \item embedded in general purpose language
  \item functional: separate \texttt{description} of program from
    \texttt{execution}
  \item initial encoding: \texttt{Free Monads}
  \item final encoding: \texttt{typeclasses + instances}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{The Road Ahead}
\end{frame}

\begin{frame}
  \frametitle{Writing Web Services With Http4s}
  \begin{itemize}
  \item define \texttt{HttpService} using the DSL
  \item \texttt{really} just \texttt{Request =>
      Task[Response]}\footnote{okay PartialFunction[Request,Task[Response]]}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Typeclasses need laws}
  \begin{itemize}
  \item<1-> typeclasses should \textit{always} come with laws
  \item<1-> what about \texttt{RunnerAlg}?
  \end{itemize}
\begin{minted}{scala}
trait RunnerAlg[F[_]] {
  def saveRunner(runner: Runner): F[Unit]
  def findRunner(id: RunnerId): F[Option[Runner]]
  def listRunner: F[Vector[Runner]]
}
\end{minted}
  \begin{itemize}
  \item<2-> \texttt{saveRunner *> saveRunner}
  \item<2-> \texttt{findRunner *> findRunner}
  \item<2-> \texttt{saveRunner *> findRunner}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Writing a DSL}
  \item write typeclasses for operations of DSL
\end{frame}

\begin{frame}[fragile]
  \frametitle{ScalaCheck}
  \begin{itemize}
  \item ScalaCheck is perfect for checking our laws
  \item defined in terms of \texttt{RunnerAlg[F[\_]]}
  \end{itemize}

\begin{minted}{scala}
forAll { (runner: Runner) =>
  run {
    RunnerAlg().saveRunner(runner) *>
      RunnerAlg().findRunner(runner.id)
  }.value should ===(runner)
}
\end{minted}
  \begin{itemize}
  \item instantiate this test for our instances
  \item pure in memory, cassandra, postgres, \dots{}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Testing laws}
  \begin{itemize}
  \item we can formulate those laws using \texttt{ScalaCheck}
  \item once for the typeclass, should hold for all instances
  \end{itemize}
\end{frame}

\end{document}
